from __future__ import annotations

from typing import TYPE_CHECKING, Generic, TypeVar

if TYPE_CHECKING:
    from narwhals.expr import Expr
    from narwhals.typing import NonNestedLiteral

ExprT = TypeVar("ExprT", bound="Expr")


class ExprListNamespace(Generic[ExprT]):
    def __init__(self, expr: ExprT) -> None:
        self._expr = expr

    def len(self) -> ExprT:
        """Return the number of elements in each list.

        Null values count towards the total.

        Examples:
            >>> import polars as pl
            >>> import narwhals as nw
            >>> df_native = pl.DataFrame({"a": [[1, 2], [3, 4, None], None, []]})
            >>> df = nw.from_native(df_native)
            >>> df.with_columns(a_len=nw.col("a").list.len())
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            |   Narwhals DataFrame   |
            |------------------------|
            |shape: (4, 2)           |
            |â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”|
            |â”‚ a            â”† a_len â”‚|
            |â”‚ ---          â”† ---   â”‚|
            |â”‚ list[i64]    â”† u32   â”‚|
            |â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•¡|
            |â”‚ [1, 2]       â”† 2     â”‚|
            |â”‚ [3, 4, null] â”† 3     â”‚|
            |â”‚ null         â”† null  â”‚|
            |â”‚ []           â”† 0     â”‚|
            |â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜|
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        """
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).list.len()
        )

    def unique(self) -> ExprT:
        """Get the unique/distinct values in the list.

        Null values are included in the result. The order of unique values is not guaranteed.

        Examples:
            >>> import polars as pl
            >>> import narwhals as nw
            >>> df_native = pl.DataFrame({"a": [[1, 1, 2], [3, 3, None], None, []]})
            >>> df = nw.from_native(df_native)
            >>> df.with_columns(a_unique=nw.col("a").list.unique())
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            |     Narwhals DataFrame     |
            |----------------------------|
            |shape: (4, 2)               |
            |â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”|
            |â”‚ a            â”† a_unique  â”‚|
            |â”‚ ---          â”† ---       â”‚|
            |â”‚ list[i64]    â”† list[i64] â”‚|
            |â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•¡|
            |â”‚ [1, 1, 2]    â”† [1, 2]    â”‚|
            |â”‚ [3, 3, null] â”† [null, 3] â”‚|
            |â”‚ null         â”† null      â”‚|
            |â”‚ []           â”† []        â”‚|
            |â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜|
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        """
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).list.unique()
        )

    def contains(self, item: NonNestedLiteral) -> ExprT:
        """Check if sublists contain the given item.

        Arguments:
            item: Item that will be checked for membership.

        Examples:
            >>> import polars as pl
            >>> import narwhals as nw
            >>> df_native = pl.DataFrame({"a": [[1, 2], None, []]})
            >>> df = nw.from_native(df_native)
            >>> df.with_columns(a_contains_1=nw.col("a").list.contains(1))
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            |     Narwhals DataFrame     |
            |----------------------------|
            |shape: (3, 2)               |
            |â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”|
            |â”‚ a         â”† a_contains_1 â”‚|
            |â”‚ ---       â”† ---          â”‚|
            |â”‚ list[i64] â”† bool         â”‚|
            |â•žâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡|
            |â”‚ [1, 2]    â”† true         â”‚|
            |â”‚ null      â”† null         â”‚|
            |â”‚ []        â”† false        â”‚|
            |â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜|
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        """
        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).list.contains(item)
        )

    def get(self, index: int) -> ExprT:
        """Return the value by index in each list.

        Negative indices are not accepted.

        Returns:
            A new expression.

        Examples:
            >>> import polars as pl
            >>> import narwhals as nw
            >>> df_native = pl.DataFrame({"a": [[1, 2], [3, 4, None], [None, 5]]})
            >>> df = nw.from_native(df_native)
            >>> df.with_columns(a_first=nw.col("a").list.get(0))
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            |    Narwhals DataFrame    |
            |--------------------------|
            |shape: (3, 2)             |
            |â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”|
            |â”‚ a            â”† a_first â”‚|
            |â”‚ ---          â”† ---     â”‚|
            |â”‚ list[i64]    â”† i64     â”‚|
            |â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡|
            |â”‚ [1, 2]       â”† 1       â”‚|
            |â”‚ [3, 4, null] â”† 3       â”‚|
            |â”‚ [null, 5]    â”† null    â”‚|
            |â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜|
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        """
        if not isinstance(index, int):
            msg = (
                f"Index must be of type 'int'. Got type '{type(index).__name__}' instead."
            )
            raise TypeError(msg)

        if index < 0:
            msg = f"Index {index} is out of bounds: should be greater than or equal to 0."
            raise ValueError(msg)

        return self._expr._with_elementwise(
            lambda plx: self._expr._to_compliant_expr(plx).list.get(index)
        )

